title:"TP Pollution en Ozone de l'air en Région Parisienne"
author: Louis Lacoste
output:
  html_document:
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction et contexte

### Les données géospatiales
La région parisienne est assimilée à un carré qui comporte 21 stations mesurant
plusieurs polluant dont l'ozone.

Présent dans l'air à environ $60 \mu g/m^3$.
Mais la circu automobile pollue et produit NO et NO2, qui s'associe à l'O2 de 
l'air et forme de l'O3 (+NO et NO2), si il y a du rayonnement élevé pour catalyser la 
réaction. Pour mesurer le rayonnement, on utilise en proxy la température.
Température élevée indique rayonnement élevé (forte corrélation). 
Donc il n'y a de la pollution à l'ozone que en été.
La réaction est réversible si il reste du NO et du NO2, donc en ville il y a peu
d'ozone car il est reconsommé sur place.


Mais avec du vent l'ozone se balade.
En dépression le vent vient de l'Ouest et balaie tout.
En situation anti-cyclonique, faible vent d'Est qui se fait piéger dans des 
zones rurales.
Donc l'endroit le plus pollué à l'ozone de la région Parisienne c'est 
Rambouillet.

Les différents seuils :

- $130\mu g/m^3$ alerte
- $180\mu g/m^3$ prise de mesure
- $360\mu g/m^3$ mesure plus forte

Période temporelle : week-end d'août 1998 (avant le 15 août).

Objectif : faire une carte
On peut faire un krigeage avec les 21 mesures prises aux stations
Mais risque d'être un peu léger !

### Les physiciens à la rescousse

Les physiciens du LMD ont mis au point un modèle physico-chimique basé sur la
météo, les émissions (inventaire, pas des mesures) et d'autres variables 
(topographie, ...). Ce modèle est valable sur toute la grille.

Ce modèle étant un modèle dynamique, il a besoin de conditions initiales dures à
poser.

En confrontant les prédictions du modèles physique et en le confrontant aux 
données, il y a des **gros biais**.


### Comparaison et combinaison
Le modèle stats aura un faible biais aux observations mais sera mauvais 
ailleurs.
Le modèle physique a un fort biais mais prend en compte la physique et sera 
meilleur plus loin

On va donc combiner les deux :
$Z^{obs}_i - Z^{mod}_i = Err_i$

Et faire un krigeage de l'erreur pour obtenir $\hat{Err_0}$ et donc reconstruire
une valeur prédite intégrant la physique :
$$ Z^{pred}_0 = Z^{mod}_0 + \hat{Err_0} $$

## Objectif et questions du sujet

On souhaite réaliser une carte quotidienne de concentration d'ozone sur la région Parisienne. Pour cela on
dispose chaque jour des sorties d'un modèle déterministe mis au point au Laboratoire de Météorologie
Dynamique (Ecole Polytechnique) et des mesures de
concentration d'ozone effectuées par AirParif en 21 stations.
Le fichier *stationsKm.txt*  contient un tableau formé des colonnes suivantes :
- colonne 1 : abscisses (en km) des stations

- colonne 2 : ordonnées (en km) des stations

- colonne 3 : mesures aux stations (en $\mu g/m^3$)

- colonne 4 : valeur du modèle aux stations

Le fichier *grilleKm.txt* contient

- colonne 1 : abscisses (en km) des points de grille

- colonne 2 : ordonnées (en km) des points de grille

- colonne 3 : valeur du modèle des points de grille

1. Faire une carte en estimant la concentration en chaque point de 
la grille par krigeage à partir des mesures aux 21 stations. 
2. Tracer la carte des concentrations données par le modèle.
Comparer avec la carte précédente. Et mettre en évidence les biais
3.  On désire combiner les 2 approches. Pour cela on corrige le modèle 
déterministe en chaque point de la grille par une estimation de
la différence concentration-modèle obtenue en krigeant les différences 
observation-modèle aux stations.     
Comparer aux deux cartes précédentes. Commenter.

On admet la présence d'un bruit de mesure de $10\mu g/m^3$ sur les observations.

# Traitement et analyse des données

## Import des données
```{r charger les packages, echo=FALSE,message=FALSE,warning=FALSE}
require(geoR)
require(ggplot2)
require(patchwork)
require(dplyr)
```

Ici on importe les données et on les converties en objet geodata

```{r import_donnees}
donnees_stats_stations <- read.table("data/stationsKm.txt", header = TRUE)

donnees_physique <- read.table("data/grilleKm.txt", header = TRUE)

geodonnees_stations <- as.geodata(donnees_stats_stations)
```

```{r premier_plot_donnees}
plot(geodonnees_stations)
```

## Premier travail géostats avec les 21 stations
```{r variogramme empirique}
vario.c = variog(geodonnees_stations,op="cloud")
plot(vario.c,main = "Nuée variographique",pch='+')

# Variogramme empirique sans paramètre
vario.b = variog(geodonnees_stations)
plot(vario.b,main = "Variogramme empirique")
# vario.b = variog(geodonnees_stations, max.dist = 100, breaks = seq(0, 90, l = 10)) # MODIF
# plot(vario.b,main = "Variogramme empirique")
```

L'erreur de mesure de $10 \mu g/m^3$ correspond à l'écart-type de l'erreur de 
mesure. Donc on prend pour pépite la valeur de variance de l'erreur de mesure 
soit 100.  
```{r variogramme ajuste}
varioest = variofit(vario.b,
    cov.model = "exponential", fix.nugget = TRUE,
    nugget = 100
)
summary(varioest)
plot(vario.b, main="modele exponential")
lines(varioest)
```

```{r krigeage}
# Pour générer la grille
# grille = expand.grid( , )
grille = donnees_physique[,1:2]
# ok pour ordinary krige, le obj.model pour utiliser le variogramme fitté
Kcontrol = krige.control(type.krige = "ok", obj.model = varioest)
# loc pour savoir sur quoi appliqué le krigeage
K = krige.conv(geodonnees_stations, loc = grille, krige = Kcontrol)
```

```{r data_stats_plot, echo = TRUE}
data_plot_krige_stations <- data.frame(
      x = grille$x, y = grille$y,
      krige.predict = K$predict, krige.var = K$krige.var
)

data_plot_stations <- data.frame(
      x = donnees_stats_stations$x,
      y = donnees_stats_stations$y
)

plot_krigeage_predict <- ggplot(data = data_plot_krige_stations) +
      aes(x = x, y = y) +
      geom_raster(aes(fill = krige.predict)) +
      scale_fill_viridis_c(limits = c(70,220)) +
      geom_point(data = data_plot_stations, aes(x = x, y = y)) +
      ggtitle("Krigeage seul") +
      theme(aspect.ratio = 1)

plot_krigeage_variance <- ggplot(data = data_plot_krige_stations) +
      aes(x = x, y = y) +
      geom_raster(aes(fill = krige.var)) +
      geom_point(data = data_plot_stations, aes(x = x, y = y)) +
      scale_fill_gradient("Variance\nde krigeage",low = "green", high = "red") +
      ggtitle("Variance du krigeage seul") +
      theme(aspect.ratio = 1)


(plot_krigeage_predict / plot_krigeage_variance) + plot_layout(ncol = 2, guides = "collect")
```

On peut voir ici qu'avec le faible nombre de données (21 stations), le krigeage
est grossier et la variance très grande. Donc la précision est très faible.

## Le modèle physique

```{r modele_physique, echo = TRUE}
geodonnees_physique <- as.geodata(donnees_physique)
plot(geodonnees_physique)
```

Et maintenant l'affichage sous la forme de carte
```{r carte_physique, echo = TRUE}
data_plot_physique <- data.frame(
      x = geodonnees_physique$coords[,1],
      y = geodonnees_physique$coords[,2], data = geodonnees_physique$data
)
plot_physique_predict <- ggplot(data = data_plot_physique) +
      aes(x = x, y = y) +
      geom_raster(aes(fill = data)) +
      scale_fill_viridis_c(limits = c(70,220)) +
      ggtitle("Modèle physique seul") +
      theme(aspect.ratio = 1)

plot_physique_predict + geom_point(data = as.data.frame(geodonnees_physique), aes(x = x, y = y))
```

Et maintenant comparons les deux cartes obtenues :
```{r comparaison_deux_methodes, echo = TRUE}
plot_physique_predict + (plot_krigeage_predict)
```

Pour le modèle physique nous n'avons pas représenté les points de données car 
il y en a à chaque point de la grille.


```{r mise_evidence_biais, echo = FALSE}
# TODO Ici on fait la diff entre modele physique et point de stations pour les stations
```

## Le meilleur des deux mondes : Krigeage de l'erreur.

```{r erreur_station, echo = FALSE}
donnees_stations_erreur <- donnees_stats_stations %>%
      mutate(erreur = z - mod) %>%
      select(x, y, erreur)
geodonnees_stations_erreur <- as.geodata(donnees_stations_erreur)
```

Nous avons donc ici les erreurs commises par le modèle physique par rapport 
aux vraies mesures.

```{r variog_erreur, echo = TRUE}
vario_err.c <- variog(geodonnees_stations_erreur, op = "cloud")
plot(vario_err.c, main = "Nuée variographique", pch = "+")

# Variogramme empirique sans paramètre
vario_err.b <- variog(geodonnees_stations_erreur)
plot(vario_err.b, main = "Variogramme empirique")
# vario.b = variog(geodonnees_stations, max.dist = 100, breaks = seq(0, 90, l = 10)) # MODIF
# plot(vario.b,main = "Variogramme empirique")
```
On a :
$$Z^{obs}_i = Z_i + \delta_i, \delta_i \sim \mathcal{N}(0, 100)$$

\begin{align*}
\underbrace{Z^{mod}_i - Z^{obs}_i}_{\tilde E_i} &= \underbrace{Z^{mod}_i - Z_i}_{E_i}  - \delta_i
\end{align*}

Et on conserve donc la même pépite.

```{r variofit_erreur, echo = TRUE}
varioest_err <- variofit(vario_err.b,
      cov.model = "gaussian", fix.nugget = TRUE,
      nugget = 100
)
summary(varioest_err)
plot(vario_err.b, main = "modele exponential")
lines(varioest_err)
```

```{r krigeage_erreur, echo = TRUE}
# Pour générer la grille
# grille = expand.grid( , )
grille <- donnees_physique[, 1:2]
# ok pour ordinary krige, le obj.model pour utiliser le variogramme fitté
Kcontrol_err = krige.control(type.krige = "ok", obj.model = varioest_err)
# loc pour savoir sur quoi appliqué le krigeage
K_err <- krige.conv(geodonnees_stations_erreur, loc = grille, krige = Kcontrol_err)
```

```{r modele_phy_stats, echo = FALSE}
donnees_stats_physique <- donnees_physique %>% mutate(
      z_corr = z - K_err$predict,
      krige.var = K_err$krige.var
)

plot_stats_physique <- ggplot(data = donnees_stats_physique) +
      aes(x = x, y = y) +
      geom_raster(aes(fill = z_corr)) +
      scale_fill_viridis_c(limits = c(70, 220)) +
      ggtitle("Modèle - Krigeage\nde l'erreur") +
      theme(aspect.ratio = 1)
plot_stats_physique
```

Comparons les 3 méthodes :
```{r comparaison_3_methodes, echo = TRUE}
plot_physique_predict + plot_krigeage_predict + plot_stats_physique + plot_layout(ncol = 2, nrow = 2, guides = "collect")
```

```{r mise_en_evidence_diff, echo = FALSE}
# TODO Mettre en évidence la correction du biais
```