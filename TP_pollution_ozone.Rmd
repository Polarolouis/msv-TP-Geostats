---
title: "TP Pollution en Ozone de l'air en Région Parisienne"
author: Louis Lacoste
output:
  html_document:
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction et contexte

### Les données géospatiales
La région parisienne est assimilée à un carré qui comporte 21 stations mesurant
plusieurs polluant dont l'ozone.

Présent dans l'air à environ $60 \mu g/m^3$.
Mais la circu automobile pollue et produit NO et NO2, qui s'associe à l'O2 de 
l'air et forme de l'O3 (+NO et NO2), si il y a du rayonnement élevé pour catalyser la 
réaction. Pour mesurer le rayonnement, on utilise en proxy la température.
Température élevée indique rayonnement élevé (forte corrélation). 
Donc il n'y a de la pollution à l'ozone que en été.
La réaction est réversible si il reste du NO et du NO2, donc en ville il y a peu
d'ozone car il est reconsommé sur place.


Mais avec du vent l'ozone se balade.
En dépression le vent vient de l'Ouest et balaie tout.
En situation anti-cyclonique, faible vent d'Est qui se fait piéger dans des 
zones rurales.
Donc l'endroit le plus pollué à l'ozone de la région Parisienne c'est 
Rambouillet.

Les différents seuils :

- $130\mu g/m^3$ alerte
- $180\mu g/m^3$ prise de mesure
- $360\mu g/m^3$ mesure plus forte

Période temporelle : week-end d'août 1998 (avant le 15 août).

Objectif : faire une carte
On peut faire un krigeage avec les 21 mesures prises aux stations
Mais risque d'être un peu léger !

### Les physiciens à la rescousse

Les physiciens du LMD ont mis au point un modèle physico-chimique basé sur la
météo, les émissions (inventaire, pas des mesures) et d'autres variables 
(topographie, ...). Ce modèle est valable sur toute la grille.

Ce modèle étant un modèle dynamique, il a besoin de conditions initiales dures à
poser.

En confrontant les prédictions du modèle physique et en le confrontant aux 
données, il y a des **gros biais**.


### Comparaison et combinaison
Le modèle stats aura un faible biais aux observations mais sera mauvais 
ailleurs.
Le modèle physique a un fort biais mais prend en compte la physique et sera 
meilleur plus loin

On va donc combiner les deux :
$Z^{obs}_i - Z^{mod}_i = Err_i$

Et faire un krigeage de l'erreur pour obtenir $\hat{Err_0}$ et donc reconstruire
une valeur prédite intégrant la physique :
$$ Z^{pred}_0 = Z^{mod}_0 + \hat{Err_0} $$

## Objectif et questions du sujet

On souhaite réaliser une carte quotidienne de concentration d'ozone sur la région Parisienne. Pour cela on
dispose chaque jour des sorties d'un modèle déterministe mis au point au Laboratoire de Météorologie
Dynamique (Ecole Polytechnique) et des mesures de
concentration d'ozone effectuées par AirParif en 21 stations.
Le fichier *stationsKm.txt*  contient un tableau formé des colonnes suivantes :
- colonne 1 : abscisses (en km) des stations

- colonne 2 : ordonnées (en km) des stations

- colonne 3 : mesures aux stations (en $\mu g/m^3$)

- colonne 4 : valeur du modèle aux stations

Le fichier *grilleKm.txt* contient

- colonne 1 : abscisses (en km) des points de grille

- colonne 2 : ordonnées (en km) des points de grille

- colonne 3 : valeur du modèle des points de grille

1. Faire une carte en estimant la concentration en chaque point de 
la grille par krigeage à partir des mesures aux 21 stations. 
2. Tracer la carte des concentrations données par le modèle.
Comparer avec la carte précédente. Et mettre en évidence les biais
3.  On désire combiner les 2 approches. Pour cela on corrige le modèle 
déterministe en chaque point de la grille par une estimation de
la différence concentration-modèle obtenue en krigeant les différences 
observation-modèle aux stations.     
Comparer aux deux cartes précédentes. Commenter.

On admet la présence d'un bruit de mesure de $10\mu g/m^3$ sur les observations.

# Traitement et analyse des données

## Import des données
```{r charger les packages, echo=FALSE,message=FALSE,warning=FALSE}
necessary_packages <- c("geoR", "ggplot2", "patchwork", "dplyr")

if (any(!(necessary_packages %in% installed.packages()))){
      install.packages(necessary_packages)
}

library(geoR)
library(ggplot2)
library(patchwork)
library(dplyr)

```

Ici on importe les données et on les converties en objet geodata

```{r import_donnees}
donnees_stats_stations <- read.table("data/stationsKm.txt", header = TRUE)

donnees_physique <- read.table("data/grilleKm.txt", header = TRUE)

geodonnees_stations <- as.geodata(donnees_stats_stations)
```

```{r premier_plot_donnees}
plot(geodonnees_stations)
```

## Premier travail géostats avec les 21 stations
```{r variogramme empirique}
vario.c = variog(geodonnees_stations,op="cloud")
plot(vario.c,main = "Nuée variographique",pch='+')

# Variogramme empirique sans paramètre
vario.b = variog(geodonnees_stations)
plot(vario.b,main = "Variogramme empirique")
# vario.b = variog(geodonnees_stations, max.dist = 100, breaks = seq(0, 90, l = 10)) # MODIF
# plot(vario.b,main = "Variogramme empirique")
```

L'erreur de mesure de $10 \mu g/m^3$ correspond à l'écart-type de l'erreur de 
mesure. Donc on prend pour pépite la valeur de variance de l'erreur de mesure 
soit 100.  
```{r variogramme ajuste}
varioest = variofit(vario.b,
    cov.model = "exponential", fix.nugget = TRUE,
    nugget = 100
)
summary(varioest)
plot(vario.b, main="modele exponential")
lines(varioest)
```

Le variogramme ajusté est beaucoup moins joli que sur les données simulés mais
cela est dû à l'utilisation de vraies données.

*Remarque :* nous avons essayé plusieurs types de variogrammes sans en trouver
un qui semble clairement meilleur. Nous avons donc choisi de rester sur un
variogramme exponentiel.

```{r krigeage}
# Pour générer la grille
# grille = expand.grid( , )
grille = donnees_physique[,1:2]
# ok pour ordinary krige, le obj.model pour utiliser le variogramme fitté
Kcontrol = krige.control(type.krige = "ok", obj.model = varioest)
# loc pour savoir sur quoi appliqué le krigeage
K = krige.conv(geodonnees_stations, loc = grille, krige = Kcontrol)
```

Après le krigeage ci-dessus nous obtenons les résultats suivants :

```{r data_stats_plot, echo = FALSE}
data_plot_krige_stations <- data.frame(
      x = grille$x, y = grille$y,
      krige.predict = K$predict, krige.var = K$krige.var
)

data_plot_stations <- data.frame(
      x = donnees_stats_stations$x,
      y = donnees_stats_stations$y
)

plot_krigeage_predict <- ggplot(data = data_plot_krige_stations) +
      aes(x = x, y = y) +
      geom_raster(aes(fill = krige.predict)) +
      scale_fill_viridis_c("Valeurs\nprédites", limits = c(70, 225)) +
      geom_point(data = data_plot_stations, aes(x = x, y = y)) +
      ggtitle("Krigeage seul") +
      theme(aspect.ratio = 1)

plot_krigeage_variance <- ggplot(data = data_plot_krige_stations) +
      aes(x = x, y = y) +
      geom_raster(aes(fill = krige.var)) +
      geom_point(data = data_plot_stations, aes(x = x, y = y)) +
      scale_fill_gradient("Variance\nde krigeage",low = "green", high = "red") +
      ggtitle("Variance du krigeage seul") +
      theme(aspect.ratio = 1)


(plot_krigeage_predict / plot_krigeage_variance) + plot_layout(ncol = 2, guides = "collect")
```

On peut voir ici qu'avec le faible nombre de données (21 stations), le krigeage
est grossier et la variance très grande. Donc la précision est très faible.

## Le modèle physique

```{r modele_physique, echo = TRUE}
geodonnees_physique <- as.geodata(donnees_physique)
plot(geodonnees_physique)
```

Et maintenant l'affichage sous la forme de carte
```{r carte_physique, echo = FALSE}
data_plot_physique <- data.frame(
      x = geodonnees_physique$coords[,1],
      y = geodonnees_physique$coords[,2], data = geodonnees_physique$data
)
plot_physique_predict <- ggplot(data = data_plot_physique) +
      aes(x = x, y = y) +
      geom_raster(aes(fill = data)) +
      scale_fill_viridis_c(limits = c(70, 225)) +
      ggtitle("Modèle physique seul") +
      theme(aspect.ratio = 1)

plot_physique_predict + geom_point(data = as.data.frame(geodonnees_physique), aes(x = x, y = y))
```

Et maintenant comparons les deux cartes obtenues :
```{r comparaison_deux_methodes, echo = FALSE}
plot_physique_predict + (plot_krigeage_predict)
```

Pour le modèle physique nous n'avons pas représenté les points de données car 
il y en a à chaque point de la grille.


```{r mise_evidence_biais, echo = FALSE}
knitr::kable(tibble("Erreur modèle physique" = donnees_stats_stations$z - donnees_stats_stations$mod))
```

Mais nous pouvons voir que le modèle physique présente des erreurs aux points 
de mesures et, majoritairement, sous-estime les valeurs réelles. 

C'est là que nous pouvons essayer de joindre les deux méthodes.

## Le meilleur des deux mondes : Krigeage de l'erreur

Voici la formule de l'erreur que nous allons chercher à kriger afin de corriger
l'erreur commise par le modèle physique.

\begin{align*}
Z^{obs}_i - Z^{mod}_i &=  Err_i \\
Z^{obs}_i &= Z^{mod}_i + Err_i
\end{align*}

```{r erreur_station, echo = TRUE}
donnees_stations_erreur <- donnees_stats_stations %>%
      mutate(erreur = z - mod) %>%
      select(x, y, erreur)
geodonnees_stations_erreur <- as.geodata(donnees_stations_erreur)
```

Nous avons donc ici les erreurs commises par le modèle physique par rapport 
aux vraies mesures.

```{r variog_erreur, echo = FALSE}
vario_err.c <- variog(geodonnees_stations_erreur, op = "cloud")
plot(vario_err.c, main = "Nuée variographique", pch = "+")

# Variogramme empirique sans paramètre
vario_err.b <- variog(geodonnees_stations_erreur)
plot(vario_err.b, main = "Variogramme empirique")
# vario.b = variog(geodonnees_stations, max.dist = 100, breaks = seq(0, 90, l = 10)) # MODIF
# plot(vario.b,main = "Variogramme empirique")
```

Pour déterminer s'il y a une pépite, nous vérifions si l'erreur de mesure 
est modifiée.

On a :
$$Z^{obs}_i = Z_i + \delta_i, \delta_i \sim \mathcal{N}(0, 100)$$

\begin{align*}
\underbrace{Z^{obs}_i - Z^{mod}_i}_{\hat Err_i} &= \underbrace{Z_i - Z^{mod}_i}_{Err_i}  + \delta_i
\end{align*}

Et on conserve donc la même pépite.

```{r variofit_erreur, echo = TRUE}
varioest_err <- variofit(vario_err.b,
      cov.model = "exponential", fix.nugget = TRUE,
      nugget = 100
)
# summary(varioest_err)
plot(vario_err.b, main = "modele exponential")
lines(varioest_err)
```

```{r krigeage_erreur, echo = TRUE}
# Pour générer la grille
# grille = expand.grid( , )
grille <- donnees_physique[, 1:2]
# ok pour ordinary krige, le obj.model pour utiliser le variogramme fitté
Kcontrol_err = krige.control(type.krige = "ok", obj.model = varioest_err)
# loc pour savoir sur quoi appliqué le krigeage
K_err <- krige.conv(geodonnees_stations_erreur, loc = grille, krige = Kcontrol_err)
```

```{r modele_phy_stats, echo = TRUE}
donnees_stats_physique <- donnees_physique %>% mutate(
      z_corr = z + K_err$predict,
      krige.var = K_err$krige.var
)
```

Et ci-dessus nous corrigeons donc les erreurs du modèle par les valeurs d'
erreurs prédites.

```{r plots_modele_phy_stats, echo = FALSE}
plot_stats_physique <- ggplot(data = donnees_stats_physique) +
      aes(x = x, y = y) +
      geom_raster(aes(fill = z_corr)) +
      scale_fill_viridis_c(limits = c(70, 225)) +
      ggtitle("Modèle - Krigeage\nde l'erreur") +
      theme(aspect.ratio = 1)

plot_erreur_variance <- ggplot(data = donnees_stats_physique) +
      aes(x = x, y = y) +
      geom_raster(aes(fill = krige.var)) +
      scale_fill_gradient2("Variance\nde krigeage\nde l'erreur",
      low = "lightblue", high = "darkorange") +
      ggtitle("Variance du Krigeage\nde l'erreur") +
      theme(aspect.ratio = 1)
plot_stats_physique + plot_erreur_variance + plot_layout(
      ncol = 2)
```

Comparons les 3 méthodes :
```{r comparaison_3_methodes, echo = FALSE}
plot_physique_predict + plot_krigeage_predict + plot_stats_physique + plot_layout(ncol = 2, nrow = 2, guides = "collect")
```

On peut voir que le krigeage de l'erreur et sa prise en compte permettent de 
corriger les biais du modèle physique.


```{r comparaison_variance_plot, echo = FALSE }
plot_krigeage_variance +
      plot_erreur_variance +
      geom_point(data = data_plot_stations, aes(x = x, y = y)) +
      plot_layout(ncol = 2, guides = "collect")
```
```{r comparaison_variance_tibbe, echo=FALSE}
knitr::kable(
      as.data.frame(
            rbind(
                  cbind(
                        t(
                              round(
                                    summary(data_plot_krige_stations$krige.var), 2
                              )
                        ),
                        "Type Krigeage" = "Mesure"
                  ),
                  cbind(
                        t(
                              round(
                                    summary(donnees_stats_physique$krige.var), 2
                              )
                        ),
                        "Type Krigeage" = "Erreur"
                  )
            )
      ),
      caption = "Tableau comparatif des variances de krigeage"
)
```

Et en regardant les variance de krigeage, nous pouvons voir que celles du 
krigeage de l'erreur sont beaucoup plus petites que pour le krigeage des 
données de concentration d'ozone.

Nous en concluons donc que l'idée de kriger l'erreur permet ici de vraiment 
gagner en précision et de profiter du modèle physique pour compléter les données
non obtenues sur le reste de la région.

# Utilisation du modèle physique corrigé par le krigeage pour la prise de mesures

Et en utilisant les seuils définis au début du TP, nous obtenons la carte 
suivante.

```{r plot_seuils, echo = FALSE}
# 130, 180, 360

donnees_stats_physique$alerte_level <- cut(donnees_stats_physique$z_corr,
      breaks = c(0, 130, 180, 360, Inf),
      labels = c("Niveau normal", "Niveau alertant", "Niveau prise de mesure", 
      "Niveau prise de mesure forte")
)

ggplot(data = donnees_stats_physique) +
      aes(x = x, y = y) +
      geom_raster(aes(fill = alerte_level)) +
      scale_fill_discrete() +
      labs(fill = "Concentration") +
      ggtitle("Zone de dépassement des seuils") +
      theme(aspect.ratio = 1)
```

Et voici donc les zones où les seuils précisés ont été dépassés. Ce qui permet
de prendre les mesures adéquates.